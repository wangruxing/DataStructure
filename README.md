# DataStructure
Book : Fundamentals of Data Structures in C, 2nd Edition. (開發圖書，(02) 8242-3988)

 cd C:\Users\NCHU_WCCC\Desktop\DataStructure\"Chapter 1 Basic Concepts"
 cd C:\Users\NCHU_WCCC\Desktop\DataStructure\"Chapter 2 Arrays & Structures"
 cd C:\Users\NCHU_WCCC\Desktop\DataStructure\"Chapter 3 Stacks and Queues"
 gcc 3.c -o 3
 ./3.exe
Program 編號先不打，等code打出來在賦予編號<br />
┌<b> Chapter 1. Basic Concepts (2019.03.16)</b><br />
├─ Program 1.13: Program 1.11 with count statements   26<br />
├─ Program 1.15: Program 1.12 with count statements added   27<br />
├─ Program 1.17: Matrix addition with count statements   29<br />
├<b> Chapter 2. Arrays & Structures (2019.03.28)</b><br />
├─ 1-dimension array addressing<br />
├─ Structures and Unions<br />
├─ Polynomial Addition - data structure 2<br />
├─ Transpose matrix<br />
├─ Fast transpose matrix<br />
├─ Sparse Matrix Multiplication<br />
├<b> Chapter 3. Stacks and Queues</b><br />
├─ Implementation stack<br />
├─ Implementation queue<br />
├─ Implementation circular queue<br />
├─ A Mazing Problem<br />
├─ infix --> postfix (2019.04.27 還需補充)<br />
├─ infix --> prefix<br />
├<b> Chapter 4. Linked Lists</b><br />
├─ 4.1 Singly Linked Lists and Chains<br />
├─ 4.2 Representation Chain in C<br />
├── Program : Create a two-node list 152<br />
├── Program : Simple insert into front of list 153<br />
├── Program : Deletion from a list 155<br />
├── Program : Printing a list 155<br />
├─ 4.3 Linked Stacks and Queues<br />
├── Program : Add to a linked stack 158<br />
├── Program : Delete from a linked stack 158<br />
├── Program : Add to a rear of a linked queue 159<br />
├── Program : Delete from the front of a linked queue 160<br />
├─ 4.4 Polynomials<br />
├── Program : Add two polynomials 163<br />
├── Program : Attach a node to the end of a list 164<br />
├── Program : Erasing a polynomial 166<br />
├── Program : _getNode_ function 167<br />
├── Program : _resNode_ function 167<br />
├── Program : Erasing a circular list 168<br />
├── Program : Adding two polynomials represented as circular lists with header nodes 169<br />
├─ 4.5 Additional List Operations<br />
├── Program : Inverting a singly linked list 171<br />
├── Program : Concatenating singly linked lists 172<br />
├── Program : Inserting at the front of a list 173<br />
├── Program : Finding the length of a circular list 173<br />
├─ 4.6 Equivalence Classes<br />
├── Program : First pass at equivalence algorithm 175<br />
├── Program : A more detailed version of the equivalence algorithm 176<br />
├── Program : Program to find equivalence calsses 178<br />
├─ 4.7 Sparse Matrices<br />
├── Program : Read in a sparse matrix 184<br />
├── Program : Wrie out a sparse matrix 184<br />
├── Program : Erase a sparse matrix 185<br />
├─ 4.8 Doubly Linked Lists <br />
├── Program : Insertion into a doubly linked circular list 188<br />
├── Program : Deletion from a doubly linked circular list 189<br />
├<b> Chapter 5. Trees</b><br />
├─ 5.1 Introduction<br />
├─ 5.2 Binary Trees<br />
├─ 5.3 Binary Tree Traversals<br />
├── Program : Inorder traversal of a binary tree 207<br />
├── Program : Preorder traversal of a binary tree 208<br />
├── Program : Postorder traversal of a binary tree 209<br />
├── Program : Iterative inorder traversal 210<br />
├── Program : Level-order traversal of a binary tree 211<br />
├─ 5.4 Additional Binary Tree Operations<br />
├── Program : Copying a binary tree 212<br />
├── Program : Testing for equality of binary trees 213<br />
├── Program : First version of satisfiability algorithm 216<br />
├─ 5.5 Threaded Binary Trees<br />
├── Program : Postorder evaluate function 217<br />
├── Program : Finding te inorder successor of a node 220<br />
├── Program : Inorder traversal of a threaded binary tree 221<br />
├─ 5.6 Heaps<br />
├── Program : Right insertion in a threaded binary tree 223<br />
├── Program : Insertion into a max heap 227<br />
├── Program : Deletion from a max heap 229<br />
├─ 5.7 Binary Search Trees<br />
├── Program : Recursive search of a binary search tree 233<br />
├── Program : Iterative search of a binary search tree 233<br />
├── Program : Insertion a dictionsry pair into a binary search tree 235<br />
├── Program : Splitting a binary search tree 238<br />
├─ 5.8 Selection Trees<br />
├─ 5.9 Forests<br />
├─ 5.10 Representation of Disjoint Sets<br />
├── Program : Initial attempt at union-find functions 250<br />
├── Program : Union function using weighting rule 252<br />
├── Program : Collapsing rule 255<br />
├─ 5.11 Counting Binary Trees<br />
├─ 5.12 References and Selected Readings<br />
├<b> Chapter 6. Graphs</b><br />
├─ 6.1 The Graph Abstract Data Type<br />
├─ 6.2 Elementary Graph Operations<br />
├── Program : Depth first search 280<br />
├── Program : Breadth first search of a graph 282<br />
├── Program : Connected components 283<br />
├── Program : Determininf _dfn_ and _low_ 289<br />
├── Program : Initialization of _dfn_ and _low_ 289<br />
├── Program : Biconnected components of a graph 290<br />
├─ 6.3 Minimum Cost Spanning Trees<br />
├── Program : Kruskal's algorithm 295<br />
├── Program : Prim's algorithm 296<br />
├─ 6.4 Shortest Paths and Transitive Closure<br />
├── Program : Single source shortest paths 302<br />
├── Program : Choosing the least cost edge 303<br />
├── Program : Bellman and Ford algorithm to compute shortest paths 307<br />
├── Program : All pairs, shortest paths function 309<br />
├─ 6.5 Activity Networks<br />
├── Program : Deign of an algorithm for topological sorting 318<br />
├── Program : Topological sorting 321<br />
├─ 6.6 References and Selected Readings<br />
├─ 6.7 Additional Exercises<br />
├<b> Chapter 7. Sorting Chapter</b><br />
├─ 7.1 Motivation<br />
├── Program : Sequential search 334<br />
├── Program : Verifying two unsorted lists using a sequential search 336<br />
├── Program : Fast verification of two sorted lists 337<br />
├─ 7.2 Insertion Sort<br />
├── Program : Insertion into a sorted list 338<br />
├── Program : Insertion sort 338<br />
├─ 7.3 Quick Sort<br />
├── Program : Quick sort 341<br />
├─ 7.4 How Fast Can We Sort?<br />
├─ 7.5 Merge Sort<br />
├── Program : Merging two sorted lists 346<br />
├── Program : A merge pass 348<br />
├── Program : Merge sort 348<br />
├── Program : Recursive merge sort 350<br />
├── Program : Merging sorted chains 351<br />
├─ 7.6 Heap Sort<br />
├── Program : Adjusting a max heap 353<br />
├── Program : heap sort 354<br />
├─ 7.7 Sorting on Several Keys<br />
├── Program : LSD radix sort 358<br />
├─ 7.8 List and Table Sort<br />
├── Program : Rearranging records using a doubly linked list 362<br />
├── Program : Rearranging records using only one link field 365<br />
├── Program : Table sort 368<br />
├─ 7.9 Summary of Internal Sorting<br />
├── Program : Random permutation generator 374<br />
├─ 7.10 External Sorting<br />
├── Program : _k_ - way merge with floating buffers 384<br />
├── Program : Run generation using a loser tree 389<br />
├── Program : Finding a binary tree with minimum weighted external path length 392<br />
└─ 7.11 References and Selected Readings<br />