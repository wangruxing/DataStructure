# DataStructure
Book : Fundamentals of Data Structures in C, 2nd Edition. (開發圖書，(02) 8242-3988)

 cd C:\Users\NCHU_WCCC\Desktop\DataStructure\"Chapter 1 Basic Concepts"
 cd C:\Users\NCHU_WCCC\Desktop\DataStructure\"Chapter 2 Arrays & Structures"
 gcc 3.c -o 3
 ./3.exe
Program 編號先不打，等code打出來在賦予編號<br />
┌<b> Chapter 1. Basic Concepts (2019.03.16)</b><br />
├─ Program 1.13: Program 1.11 with count statements   26<br />
├─ Program 1.15: Program 1.12 with count statements added   27<br />
├─ Program 1.17: Matrix addition with count statements   29<br />
├─ Program 1.1: Allocation and deallocation of memory<br />
├─ Program 1.2: Selection sort algorithm<br />
├─ Program 1.3: Comparison of two integers<br />
├─ Program 1.4: Searching an ordered list by binary search<br />
├<b> Chapter 2. Arrays & Structures</b><br />
├─ 1-dimension array addressing<br />

├── Program : Example array program 54<br />
├── Program : One-dimensional array accessed by address 54<br />
├─ 2.2 Dynamically Allocated Arrays<br />
├── Program : Dynamically create a two-dimensional array 57<br />
├─ 2.3 Structures and Unions<br />
├── Program : Function to check equality of structures 61<br />
├─ 2.4 Polynomials<br />
├── Program : Initial version of _padd_ function 68<br />
├── Program : Function to add two polynomials 70<br />
├── Program : Function to add a new term 71<br />
├─ 2.5 Spares Matrices<br />
├── Program : Transpose of a sparse matrix 77<br />
├── Program : Fast transpose of a sparse matrix 78<br />
├── Program : Sparse matrix multiplication 82<br />
├── Program : _storeSum_ function 82<br />
├─ 2.6 Representation of Multidimensional Arrays<br />
├─ 2.7 Strings<br />
├── Program : String insertion function 92<br />
├── Program : Pattern matching by checking end indices first 93<br />
├── Program : Knuth, Morris, Pratt pattern matching algorithm 96<br />
├── Program : Computing the failure function 97<br />
├─ 2.8 References And Selected Readings<br />
├─ 2.9 Additional Exercises<br />
├<b> Chapter 3. Stacks and Queues</b><br />
├─ 3.1 Stacks<br />
├── Program : Add an item to a stack 111<br />
├── Program : Delete from a stack 111<br />
├── Program : Satck full 111<br />
├─ 3.2 Stacks Using Dynamic Arrays<br />
├── Program : Satck full with array doubling 113<br />
├─ 3.3 Queues<br />
├── Program : Add to a queue 116<br />
├── Program : Delete from a queue 116<br />
├── Program : Add to a circular queue 118<br />
├── Program : Delete from a circular queue 119<br />
├─ 3.4 Circular Queues Using Dynamic Arrays<br />
├─ 3.5 A Mazing Problem<br />
├── Program : Add to a circular queue 122<br />
├── Program : Doubling queue capacity 122<br />
├── Program : Initial maze algorithm 126<br />
├─ 3.6 Evaluation of Expressions<br />
├── Program : Maze search function 128<br />
├── Program : Function to evaluate a postfix expression 133<br />
├── Program : Function to get a token from the input string 134<br />
├── Program : Function to convert from infix to postfix 137<br />
├─ 3.7 Multiple Stacks and Queues<br />
├── Program : Add an item to the _i_ th stack 140<br />
├── Program : Delete an item from the _i_ th stack 141<br />
├─ 3.8 Additional Exercises<br />
├<b> Chapter 4. Linked Lists</b><br />
├─ 4.1 Singly Linked Lists and Chains<br />
├─ 4.2 Representation Chain in C<br />
├── Program : Create a two-node list 152<br />
├── Program : Simple insert into front of list 153<br />
├── Program : Deletion from a list 155<br />
├── Program : Printing a list 155<br />
├─ 4.3 Linked Stacks and Queues<br />
├── Program : Add to a linked stack 158<br />
├── Program : Delete from a linked stack 158<br />
├── Program : Add to a rear of a linked queue 159<br />
├── Program : Delete from the front of a linked queue 160<br />
├─ 4.4 Polynomials<br />
├── Program : Add two polynomials 163<br />
├── Program : Attach a node to the end of a list 164<br />
├── Program : Erasing a polynomial 166<br />
├── Program : _getNode_ function 167<br />
├── Program : _resNode_ function 167<br />
├── Program : Erasing a circular list 168<br />
├── Program : Adding two polynomials represented as circular lists with header nodes 169<br />
├─ 4.5 Additional List Operations<br />
├── Program : Inverting a singly linked list 171<br />
├── Program : Concatenating singly linked lists 172<br />
├── Program : Inserting at the front of a list 173<br />
├── Program : Finding the length of a circular list 173<br />
├─ 4.6 Equivalence Classes<br />
├── Program : First pass at equivalence algorithm 175<br />
├── Program : A more detailed version of the equivalence algorithm 176<br />
├── Program : Program to find equivalence calsses 178<br />
├─ 4.7 Sparse Matrices<br />
├── Program : Read in a sparse matrix 184<br />
├── Program : Wrie out a sparse matrix 184<br />
├── Program : Erase a sparse matrix 185<br />
├─ 4.8 Doubly Linked Lists <br />
├── Program : Insertion into a doubly linked circular list 188<br />
├── Program : Deletion from a doubly linked circular list 189<br />
├<b> Chapter 5. Trees</b><br />
├─ 5.1 Introduction<br />
├─ 5.2 Binary Trees<br />
├─ 5.3 Binary Tree Traversals<br />
├── Program : Inorder traversal of a binary tree 207<br />
├── Program : Preorder traversal of a binary tree 208<br />
├── Program : Postorder traversal of a binary tree 209<br />
├── Program : Iterative inorder traversal 210<br />
├── Program : Level-order traversal of a binary tree 211<br />
├─ 5.4 Additional Binary Tree Operations<br />
├── Program : Copying a binary tree 212<br />
├── Program : Testing for equality of binary trees 213<br />
├── Program : First version of satisfiability algorithm 216<br />
├─ 5.5 Threaded Binary Trees<br />
├── Program : Postorder evaluate function 217<br />
├── Program : Finding te inorder successor of a node 220<br />
├── Program : Inorder traversal of a threaded binary tree 221<br />
├─ 5.6 Heaps<br />
├── Program : Right insertion in a threaded binary tree 223<br />
├── Program : Insertion into a max heap 227<br />
├── Program : Deletion from a max heap 229<br />
├─ 5.7 Binary Search Trees<br />
├── Program : Recursive search of a binary search tree 233<br />
├── Program : Iterative search of a binary search tree 233<br />
├── Program : Insertion a dictionsry pair into a binary search tree 235<br />
├── Program : Splitting a binary search tree 238<br />
├─ 5.8 Selection Trees<br />
├─ 5.9 Forests<br />
├─ 5.10 Representation of Disjoint Sets<br />
├── Program : Initial attempt at union-find functions 250<br />
├── Program : Union function using weighting rule 252<br />
├── Program : Collapsing rule 255<br />
├─ 5.11 Counting Binary Trees<br />
├─ 5.12 References and Selected Readings<br />
├<b> Chapter 6. Graphs</b><br />
├─ 6.1 The Graph Abstract Data Type<br />
├─ 6.2 Elementary Graph Operations<br />
├── Program : Depth first search 280<br />
├── Program : Breadth first search of a graph 282<br />
├── Program : Connected components 283<br />
├── Program : Determininf _dfn_ and _low_ 289<br />
├── Program : Initialization of _dfn_ and _low_ 289<br />
├── Program : Biconnected components of a graph 290<br />
├─ 6.3 Minimum Cost Spanning Trees<br />
├── Program : Kruskal's algorithm 295<br />
├── Program : Prim's algorithm 296<br />
├─ 6.4 Shortest Paths and Transitive Closure<br />
├── Program : Single source shortest paths 302<br />
├── Program : Choosing the least cost edge 303<br />
├── Program : Bellman and Ford algorithm to compute shortest paths 307<br />
├── Program : All pairs, shortest paths function 309<br />
├─ 6.5 Activity Networks<br />
├── Program : Deign of an algorithm for topological sorting 318<br />
├── Program : Topological sorting 321<br />
├─ 6.6 References and Selected Readings<br />
├─ 6.7 Additional Exercises<br />
├<b> Chapter 7. Sorting Chapter</b><br />
├─ 7.1 Motivation<br />
├── Program : Sequential search 334<br />
├── Program : Verifying two unsorted lists using a sequential search 336<br />
├── Program : Fast verification of two sorted lists 337<br />
├─ 7.2 Insertion Sort<br />
├── Program : Insertion into a sorted list 338<br />
├── Program : Insertion sort 338<br />
├─ 7.3 Quick Sort<br />
├── Program : Quick sort 341<br />
├─ 7.4 How Fast Can We Sort?<br />
├─ 7.5 Merge Sort<br />
├── Program : Merging two sorted lists 346<br />
├── Program : A merge pass 348<br />
├── Program : Merge sort 348<br />
├── Program : Recursive merge sort 350<br />
├── Program : Merging sorted chains 351<br />
├─ 7.6 Heap Sort<br />
├── Program : Adjusting a max heap 353<br />
├── Program : heap sort 354<br />
├─ 7.7 Sorting on Several Keys<br />
├── Program : LSD radix sort 358<br />
├─ 7.8 List and Table Sort<br />
├── Program : Rearranging records using a doubly linked list 362<br />
├── Program : Rearranging records using only one link field 365<br />
├── Program : Table sort 368<br />
├─ 7.9 Summary of Internal Sorting<br />
├── Program : Random permutation generator 374<br />
├─ 7.10 External Sorting<br />
├── Program : _k_ - way merge with floating buffers 384<br />
├── Program : Run generation using a loser tree 389<br />
├── Program : Finding a binary tree with minimum weighted external path length 392<br />
└─ 7.11 References and Selected Readings<br />