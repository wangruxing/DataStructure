# DataStructure
Book : Fundamentals of Data Structures in C, 2nd Edition. (開發圖書，(02) 8242-3988)

Program 編號先不打，等code打出來在賦予編號
┌<b> Chapter 1. Basic Concepts</b><br />
├─ 1.1 Overview: System Life Cycle<br />
├─ 1.2 Pointers and Dynamic Memory Allocation<br />
├── Program 1.1: Allocation and deallocation of memory 6<br />
├─ 1.3 Algorithm Specification<br />
├── Program 1.2: Selection sort 11<br />
├── Program : Searching a sorted list 12<br />
├── Program : Comparison of two integers 12<br />
├── Program : Searching an ordered list 13<br />
├── Program : Recursive implementation of binary search 15<br />
├── Program : Recursive permutation generator 16<br />
├─ 1.4 Data Abstraction<br />
├─ 1.5 Performance Analysis<br />
├── Program : Simple arithmetic function 23<br />
├── Program : Iterative function for summing a list of numbers 24<br />
├── Program : Recursive function for summing a list of numbers 24<br />
├── Program : Program 1.11 with count satements 26<br />
├── Program : Simplified version of Program 1.13 27<br />
├── Program : Program 1.12 with count satements added 27<br />
├── Program : Matrix addition 28<br />
├── Program : Matrix addition with count satements 29<br />
├── Program : Simplification of Program 1.17 29<br />
├── Program : Printing out a matrix 33<br />
├── Program : Matrix multiplication 33<br />
├── Program : Matrix product function 34<br />
├── Program : Matrix transposition function 34<br />
├── Program : Magic square program 40<br />
├─ 1.6 Performance Measurement<br />
├── Program 1.24: First timing program for selection sort 46<br />
├── Program 1.25: More accurate timing program for selection sort 47<br />
├─ 1.7 References and Selected Readings<br />
├<b> Chapter 2. Arrays & Structures</b><br />
├─ 2.1 Arrays<br />
├── Program 2.1: Example array program 54<br />
├── Program 2.2: One-dimensional array accessed by address 54<br />
├─ 2.2 Dynamically Allocated Arrays<br />
├── Program 2.3: Dynamically create a two-dimensional array 57<br />
├─ 2.3 Structures and Unions<br />
├── Program 2.4: Function to check equality of structures 61<br />
├─ 2.4 Polynomials<br />
├── Program 2.5: Initial version of _padd_ function 68<br />
├── Program 2.6: Function to add two polynomials 70<br />
├── Program 2.7: Function to add a new term 71<br />
├─ 2.5 Spares Matrices<br />
├── Program 2.8: Transpose of a sparse matrix 77<br />
├── Program 2.9: Fast transpose of a sparse matrix 78<br />
├── Program 2.10: Sparse matrix multiplication 82<br />
├── Program 2.11: _storeSum_ function 82<br />
├─ 2.6 Representation of Multidimensional Arrays<br />
├─ 2.7 Strings<br />
├── Program 2.12: String insertion function 92<br />
├── Program 2.13: Pattern matching by checking end indices first 93<br />
├── Program 2.14: Knuth, Morris, Pratt pattern matching algorithm 96<br />
├── Program 2.15: Computing the failure function 97<br />
├─ 2.8 References And Selected Readings<br />
├─ 2.9 Additional Exercises<br />
├<b> Chapter 3. Stacks and Queues</b><br />
├─ 3.1 Stacks<br />
├── Program 3.1: Add an item to a stack 111<br />
├── Program 3.2: Delete from a stack 111<br />
├── Program 3.3: Satck full 111<br />
├─ 3.2 Stacks Using Dynamic Arrays<br />
├── Program 3.4: Satck full with array doubling 113<br />
├─ 3.3 Queues<br />
├── Program 3.5: Add to a queue 116<br />
├── Program 3.6: Delete from a queue 116<br />
├── Program 3.7: Add to a circular queue 118<br />
├── Program 3.8: Delete from a circular queue 119<br />
├─ 3.4 Circular Queues Using Dynamic Arrays<br />
├─ 3.5 A Mazing Problem<br />
├── Program 3.9: Add to a circular queue 122<br />
├── Program 3.10: Doubling queue capacity 122<br />
├── Program 3.11: Initial maze algorithm 126<br />
├─ 3.6 Evaluation of Expressions<br />
├── Program 3.12: Maze search function 128<br />
├── Program 3.13: Function to evaluate a postfix expression 133<br />
├── Program 3.14: Function to get a token from the input string 134<br />
├── Program 3.15: Function to convert from infix to postfix 137<br />
├─ 3.7 Multiple Stacks and Queues<br />
├── Program 3.16: Add an item to the _i_ th stack 140<br />
├── Program 3.17: Delete an item from the _i_ th stack 141<br />
├─ 3.8 Additional Exercises<br />
├<b> Chapter 4. Linked Lists</b><br />
├─ 4.1 Singly Linked Lists and Chains<br />
├─ 4.2 Representation Chain in C<br />
├── Program 4.1: Create a two-node list 152<br />
├── Program 4.2: Simple insert into front of list 153<br />
├── Program 4.3: Deletion from a list 155<br />
├── Program 4.4: Printing a list 155<br />
├─ 4.3 Linked Stacks and Queues<br />
├── Program 4.5: Add to a linked stack 158<br />
├── Program 4.5: Delete from a linked stack 158<br />
├── Program 4.7: Add to a rear of a linked queue 159<br />
├── Program 4.8: Delete from the front of a linked queue 160<br />
├─ 4.4 Polynomials<br />
├── Program 4.9: Add two polynomials 163<br />
├── Program 4.10: Attach a node to the end of a list 164<br />
├── Program 4.11: Erasing a polynomial 166<br />
├── Program 4.12: _getNode_ function 167<br />
├── Program 4.13: _resNode_ function 167<br />
├── Program 4.14: Erasing a circular list 168<br />
├── Program 4.15: Adding two polynomials represented as circular lists with header nodes 169<br />
├─ 4.5 Additional List Operations<br />
├── Program 4.16: Inverting a singly linked list 171<br />
├── Program 4.17: Concatenating singly linked lists 172<br />
├── Program 4.18: Inserting at the front of a list 173<br />
├── Program 4.19: Finding the length of a circular list 173<br />
├─ 4.6 Equivalence Classes<br />
├── Program 4.20: First pass at equivalence algorithm 175<br />
├── Program 4.21: A more detailed version of the equivalence algorithm 176<br />
├── Program 4.22: Program to find equivalence calsses 178<br />
├─ 4.7 Sparse Matrices<br />
├── Program 4.23: Read in a sparse matrix 184<br />
├── Program 4.24: Wrie out a sparse matrix 184<br />
├── Program 4.25: Erase a sparse matrix 185<br />
├─ 4.8 Doubly Linked Lists <br />
├── Program 4.26: Insertion into a doubly linked circular list 188<br />
├── Program 4.27: Deletion from a doubly linked circular list 189<br />
├<b> Chapter 5. Trees</b><br />
├─ 5.1 Introduction<br />
├─ 5.2 Binary Trees<br />
├─ 5.3 Binary Tree Traversals<br />
├── Program 5.1: Inorder traversal of a binary tree 207<br />
├── Program 5.2: Preorder traversal of a binary tree 208<br />
├── Program 5.3: Postorder traversal of a binary tree 209<br />
├── Program 5.4: Iterative inorder traversal 210<br />
├── Program 5.5: Level-order traversal of a binary tree 211<br />
├─ 5.4 Additional Binary Tree Operations<br />
├── Program 5.6: Copying a binary tree 212<br />
├── Program 5.7: Testing for equality of binary trees 213<br />
├── Program 5.8: First version of satisfiability algorithm 216<br />
├─ 5.5 Threaded Binary Trees<br />
├── Program 5.9: Postorder evaluate function 217<br />
├── Program 5.10: Finding te inorder successor of a node 220<br />
├── Program 5.11: Inorder traversal of a threaded binary tree 221<br />
├─ 5.6 Heaps<br />
├── Program 5.12: Right insertion in a threaded binary tree 223<br />
├── Program 5.13: Insertion into a max heap 227<br />
├── Program 5.14: Deletion from a max heap 229<br />
├─ 5.7 Binary Search Trees<br />
├── Program 5.15: Recursive search of a binary search tree 233<br />
├── Program 5.16: Iterative search of a binary search tree 233<br />
├── Program 5.17: Insertion a dictionsry pair into a binary search tree 235<br />
├── Program 5.18: Splitting a binary search tree 238<br />
├─ 5.8 Selection Trees<br />
├─ 5.9 Forests<br />
├─ 5.10 Representation of Disjoint Sets<br />
├── Program 5.19: Initial attempt at union-find functions 250<br />
├── Program 5.20: Union function using weighting rule 252<br />
├── Program 5.21: Collapsing rule 255<br />
├─ 5.11 Counting Binary Trees<br />
├─ 5.12 References and Selected Readings<br />
├<b> Chapter 6. Graphs</b><br />
├─ 6.1 The Graph Abstract Data Type<br />
├─ 6.2 Elementary Graph Operations<br />
├── Program 6.1: Depth first search 280<br />
├── Program 6.2: Breadth first search of a graph 282<br />
├── Program 6.3: Connected components 283<br />
├── Program 6.4: Determininf _dfn_ and _low_ 289<br />
├── Program 6.5: Initialization of _dfn_ and _low_ 289<br />
├── Program 6.6: Biconnected components of a graph 290<br />
├─ 6.3 Minimum Cost Spanning Trees<br />
├── Program 6.7: Kruskal's algorithm 295<br />
├── Program 6.8: Prim's algorithm 296<br />
├─ 6.4 Shortest Paths and Transitive Closure<br />
├── Program 6.9: Single source shortest paths 302<br />
├── Program 6.10: Choosing the least cost edge 303<br />
├── Program 6.11: Bellman and Ford algorithm to compute shortest paths 307<br />
├── Program 6.12: All pairs, shortest paths function 309<br />
├─ 6.5 Activity Networks<br />
├── Program 6.13: Deign of an algorithm for topological sorting 318<br />
├── Program 6.14: Topological sorting 321<br />
├─ 6.6 References and Selected Readings<br />
├─ 6.7 Additional Exercises<br />
├<b> Chapter 7. Sorting Chapter</b><br />
├─ 7.1 Motivation<br />
├── Program 7.1: Sequential search 334<br />
├── Program 7.2: Verifying two unsorted lists using a sequential search 336<br />
├── Program 7.3: Fast verification of two sorted lists 337<br />
├─ 7.2 Insertion Sort<br />
├── Program 7.4: Insertion into a sorted list 338<br />
├── Program 7.5: Insertion sort 338<br />
├─ 7.3 Quick Sort<br />
├── Program 7.6: Quick sort 341<br />
├─ 7.4 How Fast Can We Sort?<br />
├─ 7.5 Merge Sort<br />
├── Program 7.7: Merging two sorted lists 346<br />
├── Program 7.8: A merge pass 348<br />
├── Program 7.9: Merge sort 348<br />
├── Program 7.10: Recursive merge sort 350<br />
├── Program 7.11: Merging sorted chains 351<br />
├─ 7.6 Heap Sort<br />
├── Program 7.12: Adjusting a max heap 353<br />
├── Program 7.13: heap sort 354<br />
├─ 7.7 Sorting on Several Keys<br />
├── Program 7.14: LSD radix sort 358<br />
├─ 7.8 List and Table Sort<br />
├── Program 7.15: Rearranging records using a doubly linked list 362<br />
├── Program 7.16: Rearranging records using only one link field 365<br />
├── Program 7.17: Table sort 368<br />
├─ 7.9 Summary of Internal Sorting<br />
├── Program 7.18: Random permutation generator 374<br />
├─ 7.10 External Sorting<br />
├── Program 7.19: _k_ - way merge with floating buffers 384<br />
├── Program 7.20: Run generation using a loser tree 389<br />
├── Program 7.21: Finding a binary tree with minimum weighted external path length 392<br />
└─ 7.11 References and Selected Readings<br />